From 96ecb2010e7de99a1382b05b7173e545d90a4bb0 Mon Sep 17 00:00:00 2001
From: Aikar <aikar@aikar.co>
Date: Wed, 27 Sep 2017 15:04:41 -0400
Subject: [PATCH] Ensure commands are not ran async

Plugins calling Player.chat("/foo") or Server.dispatchCommand() could
trigger the server to execute a command while on another thread.

These commands would then process EXPECTING to be on the main thread, leading to
very hard to trace concurrency issues.

This change will synchronize the command execution back to the main thread, causing a
big slowdown in execution but throwing an exception at same time to raise awareness
that it is happening so that plugin authors can fix their code to stop executing commands async.

diff --git a/src/main/java/net/minecraft/network/NetHandlerPlayServer.java b/src/main/java/net/minecraft/network/NetHandlerPlayServer.java
index 11d4855..02bb172 100644
--- a/src/main/java/net/minecraft/network/NetHandlerPlayServer.java
+++ b/src/main/java/net/minecraft/network/NetHandlerPlayServer.java
@@ -1479,6 +1479,29 @@ public class NetHandlerPlayServer implements INetHandlerPlayServer, ITickable {
     public void chat(String s, boolean async) {
         if (!s.isEmpty() && this.player.getChatVisibility() != EntityPlayer.EnumChatVisibility.HIDDEN) {
             if (!async && s.startsWith("/")) {
+                // Paper Start
+                if (org.spigotmc.AsyncCatcher.enabled && !org.bukkit.Bukkit.isPrimaryThread()) {
+                    final String fCommandLine = s;
+                    MinecraftServer.LOGGER.log(org.apache.logging.log4j.Level.ERROR, "Command Dispatched Async: " + fCommandLine);
+                    MinecraftServer.LOGGER.log(org.apache.logging.log4j.Level.ERROR, "Please notify author of plugin causing this execution to fix this bug! see: http://bit.ly/1oSiM6C", new Throwable());
+                    Waitable wait = new Waitable() {
+                        @Override
+                        protected Object evaluate() {
+                            chat(fCommandLine, false);
+                            return null;
+                        }
+                    };
+                    serverController.processQueue.add(wait);
+                    try {
+                        wait.get();
+                        return;
+                    } catch (InterruptedException e) {
+                        Thread.currentThread().interrupt(); // This is proper habit for java. If we aren't handling it, pass it on!
+                    } catch (Exception e) {
+                        throw new RuntimeException("Exception processing chat command", e.getCause());
+                    }
+                }
+                // Paper End
                 this.handleSlashCommand(s);
             } else if (this.player.getChatVisibility() != EntityPlayer.EnumChatVisibility.SYSTEM) {
                 Player player = this.getPlayer();
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftServer.java b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
index e004ab0..0b0a0fc 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftServer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
@@ -733,6 +733,29 @@ public final class CraftServer implements Server {
         Validate.notNull(sender, "Sender cannot be null");
         Validate.notNull(commandLine, "CommandLine cannot be null");
 
+        // Paper Start
+        if (org.spigotmc.AsyncCatcher.enabled && !Bukkit.isPrimaryThread()) {
+            final CommandSender fSender = sender;
+            final String fCommandLine = commandLine;
+            Bukkit.getLogger().log(Level.SEVERE, "Command Dispatched Async: " + commandLine);
+            Bukkit.getLogger().log(Level.SEVERE, "Please notify author of plugin causing this execution to fix this bug! see: http://bit.ly/1oSiM6C", new Throwable());
+            org.bukkit.craftbukkit.util.Waitable<Boolean> wait = new org.bukkit.craftbukkit.util.Waitable<Boolean>() {
+                @Override
+                protected Boolean evaluate() {
+                    return dispatchCommand(fSender, fCommandLine);
+                }
+            };
+            net.minecraft.server.MinecraftServer.getServer().processQueue.add(wait);
+            try {
+                return wait.get();
+            } catch (InterruptedException e) {
+                Thread.currentThread().interrupt(); // This is proper habit for java. If we aren't handling it, pass it on!
+            } catch (Exception e) {
+                throw new RuntimeException("Exception processing dispatch command", e.getCause());
+            }
+        }
+        // Paper End
+
         if (this.commandMap.dispatch(sender, commandLine)) {
             return true;
         } else {
-- 
2.14.1.windows.1

