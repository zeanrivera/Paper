From 1590c05740c7ab6a6a8f7b2238ade68eea1f5610 Mon Sep 17 00:00:00 2001
From: Aikar <aikar@aikar.co>
Date: Thu, 4 Jan 2018 21:50:43 -0600
Subject: [PATCH] Configurable Max Chunk Gens per Tick

Limit the number of generations that can occur in a single tick, forcing them
to be spread out more.

Defaulting to 10 as an average generation is going to be 3-6ms, which means 10 will
likely cause the server to lose TPS, but constrain how much.

This should result in no noticeable speed reduction in generation for servers not
lagging, and let larger servers reduce this value according to their own desires.

diff --git a/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java b/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java
index a53adc0..4a95bd2 100644
--- a/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java
+++ b/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java
@@ -469,4 +469,16 @@ public class PaperWorldConfig {
         }
         log("Max Chunk Sends Per Tick: " + maxChunkSendsPerTick);
     }
+
+    public int maxChunkGensPerTick = 10;
+    private void maxChunkGensPerTick() {
+        maxChunkGensPerTick = getInt("max-chunk-gens-per-tick", maxChunkGensPerTick);
+        if (maxChunkGensPerTick <= 0) {
+            maxChunkSendsPerTick = Integer.MAX_VALUE;
+            log("Max Chunk Gens Per Tick: Unlimited (NOT RECOMMENDED)");
+        } else {
+            log("Max Chunk Gens Per Tick: " + maxChunkGensPerTick);
+        }
+    }
+
 }
diff --git a/src/main/java/net/minecraft/server/management/PlayerChunkMap.java b/src/main/java/net/minecraft/server/management/PlayerChunkMap.java
index becfdeb..2c0db8c 100644
--- a/src/main/java/net/minecraft/server/management/PlayerChunkMap.java
+++ b/src/main/java/net/minecraft/server/management/PlayerChunkMap.java
@@ -174,6 +174,7 @@ public class PlayerChunkMap {
             try (Timing ignored = world.timings.doChunkMapPlayersNeedingChunks.startTiming()) { // Paper
             SlackActivityAccountant activityAccountant = this.world.getMinecraftServer().slackActivityAccountant;
             activityAccountant.startActivity(0.5D);
+            int chunkGensAllowed = world.paperConfig.maxChunkGensPerTick; // Paper
             Iterator iterator1 = this.entriesWithoutChunks.iterator();
 
             while (iterator1.hasNext()) {
@@ -181,6 +182,11 @@ public class PlayerChunkMap {
 
                 if (playerchunk1.getChunk() == null) {
                     boolean flag = playerchunk1.hasPlayerMatching(CAN_GENERATE_CHUNKS);
+                    // Paper start
+                    if (flag && !playerchunk1.chunkExists && chunkGensAllowed-- <= 0) {
+                        continue;
+                    }
+                    // Paper end
 
                     if (playerchunk1.providePlayerChunk(flag)) {
                         iterator1.remove();
diff --git a/src/main/java/net/minecraft/server/management/PlayerChunkMapEntry.java b/src/main/java/net/minecraft/server/management/PlayerChunkMapEntry.java
index 318b693..d3d67f0 100644
--- a/src/main/java/net/minecraft/server/management/PlayerChunkMapEntry.java
+++ b/src/main/java/net/minecraft/server/management/PlayerChunkMapEntry.java
@@ -31,6 +31,7 @@ public class PlayerChunkMapEntry {
     private int changedSectionFilter;
     private long lastUpdateInhabitedTime;
     private boolean sentToPlayers;
+    boolean chunkExists; // Paper
     private boolean loadInProgress = false;
     private Runnable loadedRunnable =
             new Runnable() {
@@ -51,6 +52,7 @@ public class PlayerChunkMapEntry {
         this.pos = new ChunkPos(chunkX, chunkZ);
         this.loadInProgress = true;
         this.chunk = mapIn.getWorldServer().getChunkProvider().getChunkAt(chunkX, chunkZ, this.loadedRunnable, false);
+        this.chunkExists = this.chunk != null || ChunkIOExecutor.hasQueuedChunkLoad(playerChunkMap.getWorldServer(), chunkX, chunkZ); // Paper
         markChunkUsed(); // Paper - delay chunk unloads
     }
 
diff --git a/src/main/java/org/bukkit/craftbukkit/chunkio/ChunkIOExecutor.java b/src/main/java/org/bukkit/craftbukkit/chunkio/ChunkIOExecutor.java
index 638b79b..81e77fd 100644
--- a/src/main/java/org/bukkit/craftbukkit/chunkio/ChunkIOExecutor.java
+++ b/src/main/java/org/bukkit/craftbukkit/chunkio/ChunkIOExecutor.java
@@ -33,4 +33,10 @@ public class ChunkIOExecutor {
     public static void tick() {
         instance.finishActive();
     }
+
+    // Paper start
+    public static boolean hasQueuedChunkLoad(World world, int x, int z) {
+        return instance.hasTask(new QueuedChunk(x, z, null, world, null));
+    }
+    // Paper end
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/util/AsynchronousExecutor.java b/src/main/java/org/bukkit/craftbukkit/util/AsynchronousExecutor.java
index caa419d..dc364ad 100644
--- a/src/main/java/org/bukkit/craftbukkit/util/AsynchronousExecutor.java
+++ b/src/main/java/org/bukkit/craftbukkit/util/AsynchronousExecutor.java
@@ -119,6 +119,12 @@ public final class AsynchronousExecutor<P, T, C, E extends Throwable> {
         this.pool.setCorePoolSize(coreSize);
     }
 
+    // Paper start
+    public boolean hasTask(P parameter) throws IllegalStateException {
+        return tasks.get(parameter) != null;
+    }
+    // Paper end
+
     public interface CallBackProvider<P, T, C, E extends Throwable> extends ThreadFactory {
         T callStage1(P var1) throws E;
 
-- 
2.15.1.windows.2

